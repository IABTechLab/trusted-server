#![allow(clippy::unwrap_used, clippy::panic)]

use std::env;
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;

use build_print::{info, warn};

fn main() {
    // Rebuild if TS sources change (belt-and-suspenders): enumerate every file under lib/
    println!("cargo:rerun-if-changed=lib");
    watch_dir_recursively(Path::new("lib"));

    // Allow opt-out or force via env
    let skip = env::var("TSJS_SKIP_BUILD")
        .map(|v| v == "1")
        .unwrap_or(false);

    let crate_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR").unwrap());
    let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());
    let ts_dir = crate_dir.join("lib");
    let dist_dir = crate_dir.join("dist");

    // Ensure dist exists
    let _ = fs::create_dir_all(&dist_dir);

    // Only try to build if we have a library project
    if !ts_dir.join("package.json").exists() {
        // No TS project; rely on prebuilt dist if present
        return;
    }

    // If Node/npm is absent, keep going if dist exists
    let npm = which::which("npm").ok();
    if npm.is_none() {
        warn!("tsjs: npm not found; will use existing dist if available");
    }

    // Install deps if node_modules missing
    if !skip {
        if let Some(npm_path) = npm.as_deref() {
            if !ts_dir.join("node_modules").exists() {
                let status = Command::new(npm_path)
                    .arg("install")
                    .current_dir(&ts_dir)
                    .status();
                if !status
                    .as_ref()
                    .map(std::process::ExitStatus::success)
                    .unwrap_or(false)
                {
                    warn!("tsjs: npm install failed; using existing dist if available");
                }
            }
        }
    }

    // Run tests if requested
    if !skip && npm.is_some() && env::var("TSJS_TEST").map(|v| v == "1").unwrap_or(false) {
        let _ = Command::new(npm.as_deref().unwrap())
            .args(["run", "test", "--", "--run"]) // ensure non-watch
            .current_dir(&ts_dir)
            .status();
    }

    // Build all module files
    if !skip {
        if let Some(npm_path) = npm.as_deref() {
            info!("tsjs: Building per-module bundles");

            let status = Command::new(npm_path)
                .args(["run", "build"])
                .current_dir(&ts_dir)
                .status();
            if !status
                .as_ref()
                .map(std::process::ExitStatus::success)
                .unwrap_or(false)
            {
                panic!("tsjs: npm run build failed - refusing to use stale bundles");
            }
        }
    }

    // Discover all tsjs-*.js files in dist/
    let mut modules: Vec<(String, String)> = Vec::new(); // (id, filename)
    if let Ok(entries) = fs::read_dir(&dist_dir) {
        for entry in entries.flatten() {
            let filename = entry.file_name().to_string_lossy().to_string();
            if let Some(id) = filename
                .strip_prefix("tsjs-")
                .and_then(|s| s.strip_suffix(".js"))
            {
                modules.push((id.to_string(), filename));
            }
        }
    }

    // Sort alphabetically but ensure "core" is always first
    modules.sort_by(|a, b| {
        if a.0 == "core" {
            std::cmp::Ordering::Less
        } else if b.0 == "core" {
            std::cmp::Ordering::Greater
        } else {
            a.0.cmp(&b.0)
        }
    });

    if modules.is_empty() {
        panic!(
            "tsjs: no tsjs-*.js files found in {:?}. Ensure `npm run build` succeeds.",
            dist_dir
        );
    }

    info!(
        "tsjs: Discovered {} module files: {:?}",
        modules.len(),
        modules
            .iter()
            .map(|(id, _)| id.as_str())
            .collect::<Vec<_>>()
    );

    // Copy each module file to OUT_DIR
    for (_, filename) in &modules {
        copy_bundle(filename, true, &crate_dir, &dist_dir, &out_dir);
    }

    // Generate tsjs_modules.rs with include_str!() for each module
    let mut codegen = String::new();
    codegen.push_str("// Auto-generated by build.rs â€” DO NOT EDIT\n\n");
    codegen.push_str("pub(crate) struct TsjsModuleMeta {\n");
    codegen.push_str("    pub id: &'static str,\n");
    codegen.push_str("    pub bundle: &'static str,\n");
    codegen.push_str("}\n\n");

    codegen.push_str(&format!(
        "pub(crate) const TSJS_MODULES: [TsjsModuleMeta; {}] = [\n",
        modules.len()
    ));
    for (id, filename) in &modules {
        codegen.push_str(&format!(
            "    TsjsModuleMeta {{\n        id: \"{id}\",\n        bundle: include_str!(concat!(env!(\"OUT_DIR\"), \"/{filename}\")),\n    }},\n"
        ));
    }
    codegen.push_str("];\n");

    let generated_path = out_dir.join("tsjs_modules.rs");
    fs::write(&generated_path, &codegen).unwrap_or_else(|e| {
        panic!(
            "tsjs: failed to write generated code to {:?}: {}",
            generated_path, e
        );
    });
}

fn copy_bundle(filename: &str, required: bool, crate_dir: &Path, dist_dir: &Path, out_dir: &Path) {
    let primary = dist_dir.join(filename);
    let fallback = crate_dir.join("dist").join(filename);
    let target = out_dir.join(filename);

    for source in [&primary, &fallback] {
        if source.exists() {
            if let Err(e) = fs::copy(source, &target) {
                if required {
                    panic!("tsjs: failed to copy {:?} to {:?}: {}", source, target, e);
                }
            }
            return;
        }
    }

    if required {
        panic!(
            "tsjs: bundle {} not found: {:?} (and fallback {:?}). Ensure Node is installed and `npm run build` succeeds, or commit dist/{}.",
            filename, primary, fallback, filename
        );
    }

    let _ = fs::write(&target, "");
}

fn watch_dir_recursively(root: &Path) {
    if !root.exists() {
        return;
    }
    let mut stack = vec![root.to_path_buf()];
    while let Some(dir) = stack.pop() {
        let read = match fs::read_dir(&dir) {
            Ok(r) => r,
            Err(_) => continue,
        };
        for entry in read.flatten() {
            let path = entry.path();
            // Always ask Cargo to rerun if this path changes
            if let Some(p) = path.to_str() {
                println!("cargo:rerun-if-changed={}", p);
            }
            if path.is_dir() {
                stack.push(path);
            }
        }
    }
}
